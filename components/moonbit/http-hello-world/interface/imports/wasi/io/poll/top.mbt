// Generated by `wit-bindgen` 0.28.0. DO NOT EDIT!
/// `pollable` represents a single I/O event which may be ready, or not.
pub type Pollable Int derive(Show, Eq)

fn wasmImportResourceDropPollable(resource : Int) = "wasi:io/poll@0.2.0" "[resource-drop]pollable"

pub fn Pollable::drop(self : Pollable) -> Unit {
  wasmImportResourceDropPollable(self.0)
}

fn wasmImportMethodPollableReady(p0 : Int) -> Int = "wasi:io/poll@0.2.0" "[method]pollable.ready"

/// Return the readiness of a pollable. This function never blocks.
///
/// Returns `true` when the pollable is ready, and `false` otherwise.
pub fn Pollable::ready(self : Pollable) -> Bool {
  let result : Int = wasmImportMethodPollableReady(self.0)
  return result != 0
}

fn wasmImportMethodPollableBlock(p0 : Int) = "wasi:io/poll@0.2.0" "[method]pollable.block"

/// `block` returns immediately if the pollable is ready, and otherwise
/// blocks until ready.
///
/// This function is equivalent to calling `poll.poll` on a list
/// containing only this pollable.
pub fn Pollable::block(self : Pollable) -> Unit {
  wasmImportMethodPollableBlock(self.0)
}

fn wasmImportPoll(p0 : Int, p1 : Int, p2 : Int) = "wasi:io/poll@0.2.0" "poll"

/// Poll for completion on a set of pollables.
///
/// This function takes a list of pollables, which identify I/O sources of
/// interest, and waits until one or more of the events is ready for I/O.
///
/// The result `list<u32>` contains one or more indices of handles in the
/// argument list that is ready for I/O.
///
/// This function traps if either:
/// - the list is empty, or:
/// - the list contains more elements than can be indexed with a `u32` value.
///
/// A timeout can be implemented by adding a pollable from the
/// wasi-clocks API to the list.
///
/// This function does not return a `result`; polling in itself does not
/// do any I/O so it doesn't fail. If any of the I/O sources identified by
/// the pollables has an error, it is indicated by marking the source as
/// being ready for I/O.
pub fn poll(in : Array[Pollable]) -> Array[UInt] {
  let address = @ffi.malloc(in.length() * 4)
  for index = 0; index < in.length(); index = index + 1 {
    let element : Pollable = in[index]
    let base = address + index * 4
    @ffi.store32(base + 0, element.0)
  }
  let return_area = @ffi.malloc(8)
  wasmImportPoll(address, in.length(), return_area)
  let array : Array[UInt] = []
  for index2 = 0; index2 < @ffi.load32(return_area + 4); index2 = index2 + 1 {
    let base1 = @ffi.load32(return_area + 0) + index2 * 4
    array.push(@ffi.load32(base1 + 0).to_uint())
  }
  @ffi.free(@ffi.load32(return_area + 0))
  @ffi.free(address)
  @ffi.free(return_area)
  return array
}
