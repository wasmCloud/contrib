// Generated by `wit-bindgen-wrpc-go` 0.2.1. DO NOT EDIT!
package container

import (
	bytes "bytes"
	context "context"
	binary "encoding/binary"
	errors "errors"
	fmt "fmt"
	wasi__blobstore__types "github.com/wasmCloud/wasmcloud-contrib/demo/providers/http-router/bindings/wasi/blobstore/types"
	wrpc "github.com/wrpc/wrpc/go"
	io "io"
	slog "log/slog"
	math "math"
	sync "sync"
	atomic "sync/atomic"
	utf8 "unicode/utf8"
)

type ContainerMetadata = wasi__blobstore__types.ContainerMetadata
type Error = wasi__blobstore__types.Error
type IncomingValue = wasi__blobstore__types.IncomingValue
type ObjectMetadata = wasi__blobstore__types.ObjectMetadata
type ObjectName = wasi__blobstore__types.ObjectName
type OutgoingValue = wasi__blobstore__types.OutgoingValue

// this defines the `container` resource
type Container interface{}

// this defines the `stream-object-names` resource which is a representation of stream<object-name>
type StreamObjectNames interface{}

// returns container name
func Container_Name(ctx__ context.Context, wrpc__ wrpc.Invoker, self wrpc.Borrow[Container]) (r0__ *wrpc.Result[string, Error], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "name", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[string, Error], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				slog.Debug("reading `result::ok` payload")
				v, err := func(r interface {
					io.ByteReader
					io.Reader
				}) (string, error) {
					var x uint32
					var s uint8
					for i := 0; i < 5; i++ {
						slog.Debug("reading string length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read string length byte: %w", err)
						}
						if s == 28 && b > 0x0f {
							return "", errors.New("string length overflows a 32-bit integer")
						}
						if b < 0x80 {
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading string bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read string bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return string(buf), errors.New("string is not valid UTF-8")
							}
							return string(buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return "", errors.New("string length overflows a 32-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
				}
				return &wrpc.Result[string, Error]{Ok: &v}, nil
			case 1:
				slog.Debug("reading `result::err` payload")
				v, err := func() (Error, error) {
					v, err := func() (wasi__blobstore__types.Error, error) {
						v, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint8
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if s == 28 && b > 0x0f {
									return "", errors.New("string length overflows a 32-bit integer")
								}
								if b < 0x80 {
									x = x | uint32(b)<<s
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						return (wasi__blobstore__types.Error)(v), err
					}()

					return (Error)(v), err
				}()

				if err != nil {
					return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
				}
				return &wrpc.Result[string, Error]{Err: &v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]container.name`: %w", err__)
		return
	}
	return
}

// returns container metadata
func Container_Info(ctx__ context.Context, wrpc__ wrpc.Invoker, self wrpc.Borrow[Container]) (r0__ *wrpc.Result[ContainerMetadata, Error], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "info", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[ContainerMetadata, Error], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				slog.Debug("reading `result::ok` payload")
				v, err := func() (*ContainerMetadata, error) {
					v, err := func(r wrpc.IndexReader, path ...uint32) (*wasi__blobstore__types.ContainerMetadata, error) {
						v := &wasi__blobstore__types.ContainerMetadata{}
						var err error
						slog.Debug("reading field", "name", "name")
						v.Name, err = func() (wasi__blobstore__types.ContainerName, error) {
							v, err := func(r interface {
								io.ByteReader
								io.Reader
							}) (string, error) {
								var x uint32
								var s uint8
								for i := 0; i < 5; i++ {
									slog.Debug("reading string length byte", "i", i)
									b, err := r.ReadByte()
									if err != nil {
										if i > 0 && err == io.EOF {
											err = io.ErrUnexpectedEOF
										}
										return "", fmt.Errorf("failed to read string length byte: %w", err)
									}
									if s == 28 && b > 0x0f {
										return "", errors.New("string length overflows a 32-bit integer")
									}
									if b < 0x80 {
										x = x | uint32(b)<<s
										buf := make([]byte, x)
										slog.Debug("reading string bytes", "len", x)
										_, err = r.Read(buf)
										if err != nil {
											return "", fmt.Errorf("failed to read string bytes: %w", err)
										}
										if !utf8.Valid(buf) {
											return string(buf), errors.New("string is not valid UTF-8")
										}
										return string(buf), nil
									}
									x |= uint32(b&0x7f) << s
									s += 7
								}
								return "", errors.New("string length overflows a 32-bit integer")
							}(r)
							return (wasi__blobstore__types.ContainerName)(v), err
						}()

						if err != nil {
							return nil, fmt.Errorf("failed to read `name` field: %w", err)
						}
						slog.Debug("reading field", "name", "created-at")
						v.CreatedAt, err = func() (wasi__blobstore__types.Timestamp, error) {
							v, err := func(r io.ByteReader) (uint64, error) {
								var x uint64
								var s uint8
								for i := 0; i < 10; i++ {
									slog.Debug("reading u64 byte", "i", i)
									b, err := r.ReadByte()
									if err != nil {
										if i > 0 && err == io.EOF {
											err = io.ErrUnexpectedEOF
										}
										return x, fmt.Errorf("failed to read u64 byte: %w", err)
									}
									if s == 63 && b > 0x01 {
										return x, errors.New("varint overflows a 64-bit integer")
									}
									if b < 0x80 {
										return x | uint64(b)<<s, nil
									}
									x |= uint64(b&0x7f) << s
									s += 7
								}
								return x, errors.New("varint overflows a 64-bit integer")
							}(r)
							return (wasi__blobstore__types.Timestamp)(v), err
						}()

						if err != nil {
							return nil, fmt.Errorf("failed to read `created-at` field: %w", err)
						}
						return v, nil
					}(r, path...)
					return (*ContainerMetadata)(v), err
				}()

				if err != nil {
					return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
				}
				return &wrpc.Result[ContainerMetadata, Error]{Ok: v}, nil
			case 1:
				slog.Debug("reading `result::err` payload")
				v, err := func() (Error, error) {
					v, err := func() (wasi__blobstore__types.Error, error) {
						v, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint8
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if s == 28 && b > 0x0f {
									return "", errors.New("string length overflows a 32-bit integer")
								}
								if b < 0x80 {
									x = x | uint32(b)<<s
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						return (wasi__blobstore__types.Error)(v), err
					}()

					return (Error)(v), err
				}()

				if err != nil {
					return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
				}
				return &wrpc.Result[ContainerMetadata, Error]{Err: &v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]container.info`: %w", err__)
		return
	}
	return
}

// retrieves an object or portion of an object, as a resource.
// Start and end offsets are inclusive.
// Once a data-blob resource has been created, the underlying bytes are held by the blobstore service for the lifetime
// of the data-blob resource, even if the object they came from is later deleted.
func Container_GetData(ctx__ context.Context, wrpc__ wrpc.Invoker, self wrpc.Borrow[Container], name string, start uint64, end uint64) (r0__ *wrpc.Result[wrpc.Own[IncomingValue], Error], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "get-data", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 4)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		write1__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(name, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `name` parameter: %w", err__)
		}
		if write1__ != nil {
			writes__[1] = write1__
		}
		write2__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
			b := make([]byte, binary.MaxVarintLen64)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing u64")
			_, err = w.Write(b[:i])
			return err
		}(start, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `start` parameter: %w", err__)
		}
		if write2__ != nil {
			writes__[2] = write2__
		}
		write3__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
			b := make([]byte, binary.MaxVarintLen64)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing u64")
			_, err = w.Write(b[:i])
			return err
		}(end, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `end` parameter: %w", err__)
		}
		if write3__ != nil {
			writes__[3] = write3__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[wrpc.Own[IncomingValue], Error], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				slog.Debug("reading `result::ok` payload")
				v, err := func(r interface {
					io.ByteReader
					io.Reader
				}) (wrpc.Own[IncomingValue], error) {
					var x uint32
					var s uint
					for i := 0; i < 5; i++ {
						slog.Debug("reading owned resource ID length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
						}
						if b < 0x80 {
							if i == 4 && b > 1 {
								return "", errors.New("owned resource ID length overflows a 32-bit integer")
							}
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading owned resource ID bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return "", errors.New("owned resource ID is not valid UTF-8")
							}
							return wrpc.Own[IncomingValue](buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return "", errors.New("owned resource ID length overflows a 32-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
				}
				return &wrpc.Result[wrpc.Own[IncomingValue], Error]{Ok: &v}, nil
			case 1:
				slog.Debug("reading `result::err` payload")
				v, err := func() (Error, error) {
					v, err := func() (wasi__blobstore__types.Error, error) {
						v, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint8
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if s == 28 && b > 0x0f {
									return "", errors.New("string length overflows a 32-bit integer")
								}
								if b < 0x80 {
									x = x | uint32(b)<<s
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						return (wasi__blobstore__types.Error)(v), err
					}()

					return (Error)(v), err
				}()

				if err != nil {
					return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
				}
				return &wrpc.Result[wrpc.Own[IncomingValue], Error]{Err: &v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]container.get-data`: %w", err__)
		return
	}
	return
}

// creates or replaces an object with the data blob.
func Container_WriteData(ctx__ context.Context, wrpc__ wrpc.Invoker, self wrpc.Borrow[Container], name string, data wrpc.Borrow[OutgoingValue]) (r0__ *wrpc.Result[struct{}, Error], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "write-data", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 3)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		write1__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(name, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `name` parameter: %w", err__)
		}
		if write1__ != nil {
			writes__[1] = write1__
		}
		write2__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(data), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `data` parameter: %w", err__)
		}
		if write2__ != nil {
			writes__[2] = write2__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[struct{}, Error], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				var v struct{}
				return &wrpc.Result[struct{}, Error]{Ok: &v}, nil
			case 1:
				slog.Debug("reading `result::err` payload")
				v, err := func() (Error, error) {
					v, err := func() (wasi__blobstore__types.Error, error) {
						v, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint8
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if s == 28 && b > 0x0f {
									return "", errors.New("string length overflows a 32-bit integer")
								}
								if b < 0x80 {
									x = x | uint32(b)<<s
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						return (wasi__blobstore__types.Error)(v), err
					}()

					return (Error)(v), err
				}()

				if err != nil {
					return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
				}
				return &wrpc.Result[struct{}, Error]{Err: &v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]container.write-data`: %w", err__)
		return
	}
	return
}

// returns list of objects in the container. Order is undefined.
func Container_ListObjects(ctx__ context.Context, wrpc__ wrpc.Invoker, self wrpc.Borrow[Container]) (r0__ *wrpc.Result[wrpc.Own[StreamObjectNames], Error], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "list-objects", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[wrpc.Own[StreamObjectNames], Error], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				slog.Debug("reading `result::ok` payload")
				v, err := func(r interface {
					io.ByteReader
					io.Reader
				}) (wrpc.Own[StreamObjectNames], error) {
					var x uint32
					var s uint
					for i := 0; i < 5; i++ {
						slog.Debug("reading owned resource ID length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
						}
						if b < 0x80 {
							if i == 4 && b > 1 {
								return "", errors.New("owned resource ID length overflows a 32-bit integer")
							}
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading owned resource ID bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return "", errors.New("owned resource ID is not valid UTF-8")
							}
							return wrpc.Own[StreamObjectNames](buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return "", errors.New("owned resource ID length overflows a 32-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
				}
				return &wrpc.Result[wrpc.Own[StreamObjectNames], Error]{Ok: &v}, nil
			case 1:
				slog.Debug("reading `result::err` payload")
				v, err := func() (Error, error) {
					v, err := func() (wasi__blobstore__types.Error, error) {
						v, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint8
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if s == 28 && b > 0x0f {
									return "", errors.New("string length overflows a 32-bit integer")
								}
								if b < 0x80 {
									x = x | uint32(b)<<s
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						return (wasi__blobstore__types.Error)(v), err
					}()

					return (Error)(v), err
				}()

				if err != nil {
					return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
				}
				return &wrpc.Result[wrpc.Own[StreamObjectNames], Error]{Err: &v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]container.list-objects`: %w", err__)
		return
	}
	return
}

// deletes object.
// does not return error if object did not exist.
func Container_DeleteObject(ctx__ context.Context, wrpc__ wrpc.Invoker, self wrpc.Borrow[Container], name string) (r0__ *wrpc.Result[struct{}, Error], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "delete-object", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 2)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		write1__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(name, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `name` parameter: %w", err__)
		}
		if write1__ != nil {
			writes__[1] = write1__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[struct{}, Error], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				var v struct{}
				return &wrpc.Result[struct{}, Error]{Ok: &v}, nil
			case 1:
				slog.Debug("reading `result::err` payload")
				v, err := func() (Error, error) {
					v, err := func() (wasi__blobstore__types.Error, error) {
						v, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint8
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if s == 28 && b > 0x0f {
									return "", errors.New("string length overflows a 32-bit integer")
								}
								if b < 0x80 {
									x = x | uint32(b)<<s
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						return (wasi__blobstore__types.Error)(v), err
					}()

					return (Error)(v), err
				}()

				if err != nil {
					return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
				}
				return &wrpc.Result[struct{}, Error]{Err: &v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]container.delete-object`: %w", err__)
		return
	}
	return
}

// deletes multiple objects in the container
func Container_DeleteObjects(ctx__ context.Context, wrpc__ wrpc.Invoker, self wrpc.Borrow[Container], names []string) (r0__ *wrpc.Result[struct{}, Error], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "delete-objects", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 2)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		write1__, err__ := func(v []string, w interface {
			io.ByteWriter
			io.Writer
		}) (write func(wrpc.IndexWriter) error, err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing list length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
			}
			slog.Debug("writing list elements")
			writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
			for i, e := range v {
				write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
					n := len(v)
					if n > math.MaxUint32 {
						return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
					}
					if err = func(v int, w io.Writer) error {
						b := make([]byte, binary.MaxVarintLen32)
						i := binary.PutUvarint(b, uint64(v))
						slog.Debug("writing string byte length", "len", n)
						_, err = w.Write(b[:i])
						return err
					}(n, w); err != nil {
						return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
					}
					slog.Debug("writing string bytes")
					_, err = w.Write([]byte(v))
					if err != nil {
						return fmt.Errorf("failed to write string bytes: %w", err)
					}
					return nil
				}(e, w)
				if err != nil {
					return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
				}
				if write != nil {
					writes[uint32(i)] = write
				}
			}
			if len(writes) > 0 {
				return func(w wrpc.IndexWriter) error {
					var wg sync.WaitGroup
					var wgErr atomic.Value
					for index, write := range writes {
						wg.Add(1)
						w, err := w.Index(index)
						if err != nil {
							return fmt.Errorf("failed to index writer: %w", err)
						}
						write := write
						go func() {
							defer wg.Done()
							if err := write(w); err != nil {
								wgErr.Store(err)
							}
						}()
					}
					wg.Wait()
					err := wgErr.Load()
					if err == nil {
						return nil
					}
					return err.(error)
				}, nil
			}
			return nil, nil
		}(names, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `names` parameter: %w", err__)
		}
		if write1__ != nil {
			writes__[1] = write1__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[struct{}, Error], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				var v struct{}
				return &wrpc.Result[struct{}, Error]{Ok: &v}, nil
			case 1:
				slog.Debug("reading `result::err` payload")
				v, err := func() (Error, error) {
					v, err := func() (wasi__blobstore__types.Error, error) {
						v, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint8
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if s == 28 && b > 0x0f {
									return "", errors.New("string length overflows a 32-bit integer")
								}
								if b < 0x80 {
									x = x | uint32(b)<<s
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						return (wasi__blobstore__types.Error)(v), err
					}()

					return (Error)(v), err
				}()

				if err != nil {
					return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
				}
				return &wrpc.Result[struct{}, Error]{Err: &v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]container.delete-objects`: %w", err__)
		return
	}
	return
}

// returns true if the object exists in this container
func Container_HasObject(ctx__ context.Context, wrpc__ wrpc.Invoker, self wrpc.Borrow[Container], name string) (r0__ *wrpc.Result[bool, Error], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "has-object", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 2)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		write1__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(name, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `name` parameter: %w", err__)
		}
		if write1__ != nil {
			writes__[1] = write1__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[bool, Error], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				slog.Debug("reading `result::ok` payload")
				v, err := func(r io.ByteReader) (bool, error) {
					slog.Debug("reading bool byte")
					v, err := r.ReadByte()
					if err != nil {
						slog.Debug("reading bool", "value", false)
						return false, fmt.Errorf("failed to read bool byte: %w", err)
					}
					switch v {
					case 0:
						return false, nil
					case 1:
						return true, nil
					default:
						return false, fmt.Errorf("invalid bool value %d", v)
					}
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
				}
				return &wrpc.Result[bool, Error]{Ok: &v}, nil
			case 1:
				slog.Debug("reading `result::err` payload")
				v, err := func() (Error, error) {
					v, err := func() (wasi__blobstore__types.Error, error) {
						v, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint8
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if s == 28 && b > 0x0f {
									return "", errors.New("string length overflows a 32-bit integer")
								}
								if b < 0x80 {
									x = x | uint32(b)<<s
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						return (wasi__blobstore__types.Error)(v), err
					}()

					return (Error)(v), err
				}()

				if err != nil {
					return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
				}
				return &wrpc.Result[bool, Error]{Err: &v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]container.has-object`: %w", err__)
		return
	}
	return
}

// returns metadata for the object
func Container_ObjectInfo(ctx__ context.Context, wrpc__ wrpc.Invoker, self wrpc.Borrow[Container], name string) (r0__ *wrpc.Result[ObjectMetadata, Error], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "object-info", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 2)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		write1__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(name, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `name` parameter: %w", err__)
		}
		if write1__ != nil {
			writes__[1] = write1__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[ObjectMetadata, Error], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				slog.Debug("reading `result::ok` payload")
				v, err := func() (*ObjectMetadata, error) {
					v, err := func(r wrpc.IndexReader, path ...uint32) (*wasi__blobstore__types.ObjectMetadata, error) {
						v := &wasi__blobstore__types.ObjectMetadata{}
						var err error
						slog.Debug("reading field", "name", "name")
						v.Name, err = func() (wasi__blobstore__types.ObjectName, error) {
							v, err := func(r interface {
								io.ByteReader
								io.Reader
							}) (string, error) {
								var x uint32
								var s uint8
								for i := 0; i < 5; i++ {
									slog.Debug("reading string length byte", "i", i)
									b, err := r.ReadByte()
									if err != nil {
										if i > 0 && err == io.EOF {
											err = io.ErrUnexpectedEOF
										}
										return "", fmt.Errorf("failed to read string length byte: %w", err)
									}
									if s == 28 && b > 0x0f {
										return "", errors.New("string length overflows a 32-bit integer")
									}
									if b < 0x80 {
										x = x | uint32(b)<<s
										buf := make([]byte, x)
										slog.Debug("reading string bytes", "len", x)
										_, err = r.Read(buf)
										if err != nil {
											return "", fmt.Errorf("failed to read string bytes: %w", err)
										}
										if !utf8.Valid(buf) {
											return string(buf), errors.New("string is not valid UTF-8")
										}
										return string(buf), nil
									}
									x |= uint32(b&0x7f) << s
									s += 7
								}
								return "", errors.New("string length overflows a 32-bit integer")
							}(r)
							return (wasi__blobstore__types.ObjectName)(v), err
						}()

						if err != nil {
							return nil, fmt.Errorf("failed to read `name` field: %w", err)
						}
						slog.Debug("reading field", "name", "container")
						v.Container, err = func() (wasi__blobstore__types.ContainerName, error) {
							v, err := func(r interface {
								io.ByteReader
								io.Reader
							}) (string, error) {
								var x uint32
								var s uint8
								for i := 0; i < 5; i++ {
									slog.Debug("reading string length byte", "i", i)
									b, err := r.ReadByte()
									if err != nil {
										if i > 0 && err == io.EOF {
											err = io.ErrUnexpectedEOF
										}
										return "", fmt.Errorf("failed to read string length byte: %w", err)
									}
									if s == 28 && b > 0x0f {
										return "", errors.New("string length overflows a 32-bit integer")
									}
									if b < 0x80 {
										x = x | uint32(b)<<s
										buf := make([]byte, x)
										slog.Debug("reading string bytes", "len", x)
										_, err = r.Read(buf)
										if err != nil {
											return "", fmt.Errorf("failed to read string bytes: %w", err)
										}
										if !utf8.Valid(buf) {
											return string(buf), errors.New("string is not valid UTF-8")
										}
										return string(buf), nil
									}
									x |= uint32(b&0x7f) << s
									s += 7
								}
								return "", errors.New("string length overflows a 32-bit integer")
							}(r)
							return (wasi__blobstore__types.ContainerName)(v), err
						}()

						if err != nil {
							return nil, fmt.Errorf("failed to read `container` field: %w", err)
						}
						slog.Debug("reading field", "name", "created-at")
						v.CreatedAt, err = func() (wasi__blobstore__types.Timestamp, error) {
							v, err := func(r io.ByteReader) (uint64, error) {
								var x uint64
								var s uint8
								for i := 0; i < 10; i++ {
									slog.Debug("reading u64 byte", "i", i)
									b, err := r.ReadByte()
									if err != nil {
										if i > 0 && err == io.EOF {
											err = io.ErrUnexpectedEOF
										}
										return x, fmt.Errorf("failed to read u64 byte: %w", err)
									}
									if s == 63 && b > 0x01 {
										return x, errors.New("varint overflows a 64-bit integer")
									}
									if b < 0x80 {
										return x | uint64(b)<<s, nil
									}
									x |= uint64(b&0x7f) << s
									s += 7
								}
								return x, errors.New("varint overflows a 64-bit integer")
							}(r)
							return (wasi__blobstore__types.Timestamp)(v), err
						}()

						if err != nil {
							return nil, fmt.Errorf("failed to read `created-at` field: %w", err)
						}
						slog.Debug("reading field", "name", "size")
						v.Size, err = func() (wasi__blobstore__types.ObjectSize, error) {
							v, err := func(r io.ByteReader) (uint64, error) {
								var x uint64
								var s uint8
								for i := 0; i < 10; i++ {
									slog.Debug("reading u64 byte", "i", i)
									b, err := r.ReadByte()
									if err != nil {
										if i > 0 && err == io.EOF {
											err = io.ErrUnexpectedEOF
										}
										return x, fmt.Errorf("failed to read u64 byte: %w", err)
									}
									if s == 63 && b > 0x01 {
										return x, errors.New("varint overflows a 64-bit integer")
									}
									if b < 0x80 {
										return x | uint64(b)<<s, nil
									}
									x |= uint64(b&0x7f) << s
									s += 7
								}
								return x, errors.New("varint overflows a 64-bit integer")
							}(r)
							return (wasi__blobstore__types.ObjectSize)(v), err
						}()

						if err != nil {
							return nil, fmt.Errorf("failed to read `size` field: %w", err)
						}
						return v, nil
					}(r, path...)
					return (*ObjectMetadata)(v), err
				}()

				if err != nil {
					return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
				}
				return &wrpc.Result[ObjectMetadata, Error]{Ok: v}, nil
			case 1:
				slog.Debug("reading `result::err` payload")
				v, err := func() (Error, error) {
					v, err := func() (wasi__blobstore__types.Error, error) {
						v, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint8
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if s == 28 && b > 0x0f {
									return "", errors.New("string length overflows a 32-bit integer")
								}
								if b < 0x80 {
									x = x | uint32(b)<<s
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						return (wasi__blobstore__types.Error)(v), err
					}()

					return (Error)(v), err
				}()

				if err != nil {
					return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
				}
				return &wrpc.Result[ObjectMetadata, Error]{Err: &v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]container.object-info`: %w", err__)
		return
	}
	return
}

// removes all objects within the container, leaving the container empty.
func Container_Clear(ctx__ context.Context, wrpc__ wrpc.Invoker, self wrpc.Borrow[Container]) (r0__ *wrpc.Result[struct{}, Error], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "clear", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[struct{}, Error], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				var v struct{}
				return &wrpc.Result[struct{}, Error]{Ok: &v}, nil
			case 1:
				slog.Debug("reading `result::err` payload")
				v, err := func() (Error, error) {
					v, err := func() (wasi__blobstore__types.Error, error) {
						v, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint8
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if s == 28 && b > 0x0f {
									return "", errors.New("string length overflows a 32-bit integer")
								}
								if b < 0x80 {
									x = x | uint32(b)<<s
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						return (wasi__blobstore__types.Error)(v), err
					}()

					return (Error)(v), err
				}()

				if err != nil {
					return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
				}
				return &wrpc.Result[struct{}, Error]{Err: &v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]container.clear`: %w", err__)
		return
	}
	return
}

// reads the next number of objects from the stream
//
// This function returns the list of objects read, and a boolean indicating if the end of the stream was reached.
func StreamObjectNames_ReadStreamObjectNames(ctx__ context.Context, wrpc__ wrpc.Invoker, self wrpc.Borrow[StreamObjectNames], len_ uint64) (r0__ *wrpc.Result[wrpc.Tuple2[[]string, bool], Error], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "read-stream-object-names", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 2)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		write1__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
			b := make([]byte, binary.MaxVarintLen64)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing u64")
			_, err = w.Write(b[:i])
			return err
		}(len_, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `len` parameter: %w", err__)
		}
		if write1__ != nil {
			writes__[1] = write1__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[wrpc.Tuple2[[]string, bool], Error], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				slog.Debug("reading `result::ok` payload")
				v, err := func(r wrpc.IndexReader, path ...uint32) (*wrpc.Tuple2[[]string, bool], error) {
					v := &wrpc.Tuple2[[]string, bool]{}
					var err error
					slog.Debug("reading tuple element 0")
					v.V0, err = func(r wrpc.IndexReader, path ...uint32) ([]string, error) {
						var x uint32
						var s uint
						for i := 0; i < 5; i++ {
							slog.Debug("reading list length byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return nil, fmt.Errorf("failed to read list length byte: %w", err)
							}
							if b < 0x80 {
								if i == 4 && b > 1 {
									return nil, errors.New("list length overflows a 32-bit integer")
								}
								x = x | uint32(b)<<s
								vs := make([]string, x)
								for i := range vs {
									slog.Debug("reading list element", "i", i)
									vs[i], err = func() (ObjectName, error) {
										v, err := func() (wasi__blobstore__types.ObjectName, error) {
											v, err := func(r interface {
												io.ByteReader
												io.Reader
											}) (string, error) {
												var x uint32
												var s uint8
												for i := 0; i < 5; i++ {
													slog.Debug("reading string length byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return "", fmt.Errorf("failed to read string length byte: %w", err)
													}
													if s == 28 && b > 0x0f {
														return "", errors.New("string length overflows a 32-bit integer")
													}
													if b < 0x80 {
														x = x | uint32(b)<<s
														buf := make([]byte, x)
														slog.Debug("reading string bytes", "len", x)
														_, err = r.Read(buf)
														if err != nil {
															return "", fmt.Errorf("failed to read string bytes: %w", err)
														}
														if !utf8.Valid(buf) {
															return string(buf), errors.New("string is not valid UTF-8")
														}
														return string(buf), nil
													}
													x |= uint32(b&0x7f) << s
													s += 7
												}
												return "", errors.New("string length overflows a 32-bit integer")
											}(r)
											return (wasi__blobstore__types.ObjectName)(v), err
										}()

										return (ObjectName)(v), err
									}()

									if err != nil {
										return nil, fmt.Errorf("failed to read list element %d: %w", i, err)
									}
								}
								return vs, nil
							}
							x |= uint32(b&0x7f) << s
							s += 7
						}
						return nil, errors.New("list length overflows a 32-bit integer")
					}(r, append(path, 0)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read tuple element 0: %w", err)
					}
					slog.Debug("reading tuple element 1")
					v.V1, err = func(r io.ByteReader) (bool, error) {
						slog.Debug("reading bool byte")
						v, err := r.ReadByte()
						if err != nil {
							slog.Debug("reading bool", "value", false)
							return false, fmt.Errorf("failed to read bool byte: %w", err)
						}
						switch v {
						case 0:
							return false, nil
						case 1:
							return true, nil
						default:
							return false, fmt.Errorf("invalid bool value %d", v)
						}
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read tuple element 1: %w", err)
					}
					return v, nil
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
				}
				return &wrpc.Result[wrpc.Tuple2[[]string, bool], Error]{Ok: v}, nil
			case 1:
				slog.Debug("reading `result::err` payload")
				v, err := func() (Error, error) {
					v, err := func() (wasi__blobstore__types.Error, error) {
						v, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint8
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if s == 28 && b > 0x0f {
									return "", errors.New("string length overflows a 32-bit integer")
								}
								if b < 0x80 {
									x = x | uint32(b)<<s
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						return (wasi__blobstore__types.Error)(v), err
					}()

					return (Error)(v), err
				}()

				if err != nil {
					return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
				}
				return &wrpc.Result[wrpc.Tuple2[[]string, bool], Error]{Err: &v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]stream-object-names.read-stream-object-names`: %w", err__)
		return
	}
	return
}

// skip the next number of objects in the stream
//
// This function returns the number of objects skipped, and a boolean indicating if the end of the stream was reached.
func StreamObjectNames_SkipStreamObjectNames(ctx__ context.Context, wrpc__ wrpc.Invoker, self wrpc.Borrow[StreamObjectNames], num uint64) (r0__ *wrpc.Result[wrpc.Tuple2[uint64, bool], Error], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "skip-stream-object-names", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 2)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		write1__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
			b := make([]byte, binary.MaxVarintLen64)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing u64")
			_, err = w.Write(b[:i])
			return err
		}(num, &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `num` parameter: %w", err__)
		}
		if write1__ != nil {
			writes__[1] = write1__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[wrpc.Tuple2[uint64, bool], Error], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				slog.Debug("reading `result::ok` payload")
				v, err := func(r wrpc.IndexReader, path ...uint32) (*wrpc.Tuple2[uint64, bool], error) {
					v := &wrpc.Tuple2[uint64, bool]{}
					var err error
					slog.Debug("reading tuple element 0")
					v.V0, err = func(r io.ByteReader) (uint64, error) {
						var x uint64
						var s uint8
						for i := 0; i < 10; i++ {
							slog.Debug("reading u64 byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u64 byte: %w", err)
							}
							if s == 63 && b > 0x01 {
								return x, errors.New("varint overflows a 64-bit integer")
							}
							if b < 0x80 {
								return x | uint64(b)<<s, nil
							}
							x |= uint64(b&0x7f) << s
							s += 7
						}
						return x, errors.New("varint overflows a 64-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read tuple element 0: %w", err)
					}
					slog.Debug("reading tuple element 1")
					v.V1, err = func(r io.ByteReader) (bool, error) {
						slog.Debug("reading bool byte")
						v, err := r.ReadByte()
						if err != nil {
							slog.Debug("reading bool", "value", false)
							return false, fmt.Errorf("failed to read bool byte: %w", err)
						}
						switch v {
						case 0:
							return false, nil
						case 1:
							return true, nil
						default:
							return false, fmt.Errorf("invalid bool value %d", v)
						}
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read tuple element 1: %w", err)
					}
					return v, nil
				}(r, path...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
				}
				return &wrpc.Result[wrpc.Tuple2[uint64, bool], Error]{Ok: v}, nil
			case 1:
				slog.Debug("reading `result::err` payload")
				v, err := func() (Error, error) {
					v, err := func() (wasi__blobstore__types.Error, error) {
						v, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint8
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if s == 28 && b > 0x0f {
									return "", errors.New("string length overflows a 32-bit integer")
								}
								if b < 0x80 {
									x = x | uint32(b)<<s
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						return (wasi__blobstore__types.Error)(v), err
					}()

					return (Error)(v), err
				}()

				if err != nil {
					return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
				}
				return &wrpc.Result[wrpc.Tuple2[uint64, bool], Error]{Err: &v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]stream-object-names.skip-stream-object-names`: %w", err__)
		return
	}
	return
}
