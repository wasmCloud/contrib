// Generated by `wit-bindgen-wrpc-go` 0.2.1. DO NOT EDIT!
package types

import (
	bytes "bytes"
	context "context"
	binary "encoding/binary"
	errors "errors"
	fmt "fmt"
	wasi__io__streams "github.com/wasmCloud/wasmcloud-contrib/demo/providers/http-router/bindings/wasi/io/streams"
	wrpc "github.com/wrpc/wrpc/go"
	io "io"
	slog "log/slog"
	math "math"
	sync "sync"
	atomic "sync/atomic"
	utf8 "unicode/utf8"
)

type InputStream = wasi__io__streams.InputStream
type OutputStream = wasi__io__streams.OutputStream

// name of a container, a collection of objects.
// The container name may be any valid UTF-8 string.
type ContainerName = string

// name of an object within a container
// The object name may be any valid UTF-8 string.
type ObjectName = string

// TODO: define timestamp to include seconds since
// Unix epoch and nanoseconds
// https://github.com/WebAssembly/wasi-blob-store/issues/7
type Timestamp = uint64

// size of an object, in bytes
type ObjectSize = uint64
type Error = string

// information about a container
type ContainerMetadata struct {
	// the container's name
	Name string
	// date and time container was created
	CreatedAt uint64
}

func (v *ContainerMetadata) String() string { return "ContainerMetadata" }

func (v *ContainerMetadata) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	writes := make(map[uint32]func(wrpc.IndexWriter) error, 2)
	slog.Debug("writing field", "name", "name")
	write0, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
		n := len(v)
		if n > math.MaxUint32 {
			return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
		}
		if err = func(v int, w io.Writer) error {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing string byte length", "len", n)
			_, err = w.Write(b[:i])
			return err
		}(n, w); err != nil {
			return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
		}
		slog.Debug("writing string bytes")
		_, err = w.Write([]byte(v))
		if err != nil {
			return fmt.Errorf("failed to write string bytes: %w", err)
		}
		return nil
	}(v.Name, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `name` field: %w", err)
	}
	if write0 != nil {
		writes[0] = write0
	}
	slog.Debug("writing field", "name", "created-at")
	write1, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
		b := make([]byte, binary.MaxVarintLen64)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u64")
		_, err = w.Write(b[:i])
		return err
	}(v.CreatedAt, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `created-at` field: %w", err)
	}
	if write1 != nil {
		writes[1] = write1
	}

	if len(writes) > 0 {
		return func(w wrpc.IndexWriter) error {
			var wg sync.WaitGroup
			var wgErr atomic.Value
			for index, write := range writes {
				wg.Add(1)
				w, err := w.Index(index)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				write := write
				go func() {
					defer wg.Done()
					if err := write(w); err != nil {
						wgErr.Store(err)
					}
				}()
			}
			wg.Wait()
			err := wgErr.Load()
			if err == nil {
				return nil
			}
			return err.(error)
		}, nil
	}
	return nil, nil
}

// information about an object
type ObjectMetadata struct {
	// the object's name
	Name string
	// the object's parent container
	Container string
	// date and time the object was created
	CreatedAt uint64
	// size of the object, in bytes
	Size uint64
}

func (v *ObjectMetadata) String() string { return "ObjectMetadata" }

func (v *ObjectMetadata) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	writes := make(map[uint32]func(wrpc.IndexWriter) error, 4)
	slog.Debug("writing field", "name", "name")
	write0, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
		n := len(v)
		if n > math.MaxUint32 {
			return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
		}
		if err = func(v int, w io.Writer) error {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing string byte length", "len", n)
			_, err = w.Write(b[:i])
			return err
		}(n, w); err != nil {
			return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
		}
		slog.Debug("writing string bytes")
		_, err = w.Write([]byte(v))
		if err != nil {
			return fmt.Errorf("failed to write string bytes: %w", err)
		}
		return nil
	}(v.Name, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `name` field: %w", err)
	}
	if write0 != nil {
		writes[0] = write0
	}
	slog.Debug("writing field", "name", "container")
	write1, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
		n := len(v)
		if n > math.MaxUint32 {
			return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
		}
		if err = func(v int, w io.Writer) error {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing string byte length", "len", n)
			_, err = w.Write(b[:i])
			return err
		}(n, w); err != nil {
			return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
		}
		slog.Debug("writing string bytes")
		_, err = w.Write([]byte(v))
		if err != nil {
			return fmt.Errorf("failed to write string bytes: %w", err)
		}
		return nil
	}(v.Container, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `container` field: %w", err)
	}
	if write1 != nil {
		writes[1] = write1
	}
	slog.Debug("writing field", "name", "created-at")
	write2, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
		b := make([]byte, binary.MaxVarintLen64)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u64")
		_, err = w.Write(b[:i])
		return err
	}(v.CreatedAt, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `created-at` field: %w", err)
	}
	if write2 != nil {
		writes[2] = write2
	}
	slog.Debug("writing field", "name", "size")
	write3, err := (func(wrpc.IndexWriter) error)(nil), func(v uint64, w io.Writer) (err error) {
		b := make([]byte, binary.MaxVarintLen64)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u64")
		_, err = w.Write(b[:i])
		return err
	}(v.Size, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `size` field: %w", err)
	}
	if write3 != nil {
		writes[3] = write3
	}

	if len(writes) > 0 {
		return func(w wrpc.IndexWriter) error {
			var wg sync.WaitGroup
			var wgErr atomic.Value
			for index, write := range writes {
				wg.Add(1)
				w, err := w.Index(index)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				write := write
				go func() {
					defer wg.Done()
					if err := write(w); err != nil {
						wgErr.Store(err)
					}
				}()
			}
			wg.Wait()
			err := wgErr.Load()
			if err == nil {
				return nil
			}
			return err.(error)
		}, nil
	}
	return nil, nil
}

// identifier for an object that includes its container name
type ObjectId struct {
	Container string
	Object    string
}

func (v *ObjectId) String() string { return "ObjectId" }

func (v *ObjectId) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	writes := make(map[uint32]func(wrpc.IndexWriter) error, 2)
	slog.Debug("writing field", "name", "container")
	write0, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
		n := len(v)
		if n > math.MaxUint32 {
			return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
		}
		if err = func(v int, w io.Writer) error {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing string byte length", "len", n)
			_, err = w.Write(b[:i])
			return err
		}(n, w); err != nil {
			return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
		}
		slog.Debug("writing string bytes")
		_, err = w.Write([]byte(v))
		if err != nil {
			return fmt.Errorf("failed to write string bytes: %w", err)
		}
		return nil
	}(v.Container, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `container` field: %w", err)
	}
	if write0 != nil {
		writes[0] = write0
	}
	slog.Debug("writing field", "name", "object")
	write1, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
		n := len(v)
		if n > math.MaxUint32 {
			return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
		}
		if err = func(v int, w io.Writer) error {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing string byte length", "len", n)
			_, err = w.Write(b[:i])
			return err
		}(n, w); err != nil {
			return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
		}
		slog.Debug("writing string bytes")
		_, err = w.Write([]byte(v))
		if err != nil {
			return fmt.Errorf("failed to write string bytes: %w", err)
		}
		return nil
	}(v.Object, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `object` field: %w", err)
	}
	if write1 != nil {
		writes[1] = write1
	}

	if len(writes) > 0 {
		return func(w wrpc.IndexWriter) error {
			var wg sync.WaitGroup
			var wgErr atomic.Value
			for index, write := range writes {
				wg.Add(1)
				w, err := w.Index(index)
				if err != nil {
					return fmt.Errorf("failed to index writer: %w", err)
				}
				write := write
				go func() {
					defer wg.Done()
					if err := write(w); err != nil {
						wgErr.Store(err)
					}
				}()
			}
			wg.Wait()
			err := wgErr.Load()
			if err == nil {
				return nil
			}
			return err.(error)
		}, nil
	}
	return nil, nil
}

// A data is the data stored in a data blob. The value can be of any type
// that can be represented in a byte array. It provides a way to write the value
// to the output-stream defined in the `wasi-io` interface.
// Soon: switch to `resource value { ... }`
type OutgoingValue interface{}

// A incoming-value is a wrapper around a value. It provides a way to read the value
// from the input-stream defined in the `wasi-io` interface.
//
// The incoming-value provides two ways to consume the value:
// 1. `incoming-value-consume-sync` consumes the value synchronously and returns the
// value as a list of bytes.
// 2. `incoming-value-consume-async` consumes the value asynchronously and returns the
// value as an input-stream.
// Soon: switch to `resource incoming-value { ... }`
type IncomingValue interface{}
type IncomingValueAsyncBody = InputStream
type IncomingValueSyncBody = []uint8

func OutgoingValue_NewOutgoingValue(ctx__ context.Context, wrpc__ wrpc.Invoker) (r0__ wrpc.Own[OutgoingValue], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, "wasi:blobstore/types@0.2.0-draft", "outgoing-value.new-outgoing-value", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		_, err__ = w__.Write(nil)
		if err__ != nil {
			return fmt.Errorf("failed to write empty parameters: %w", err__)
		}
		r0__, err__ = func(r interface {
			io.ByteReader
			io.Reader
		}) (wrpc.Own[OutgoingValue], error) {
			var x uint32
			var s uint
			for i := 0; i < 5; i++ {
				slog.Debug("reading owned resource ID length byte", "i", i)
				b, err := r.ReadByte()
				if err != nil {
					if i > 0 && err == io.EOF {
						err = io.ErrUnexpectedEOF
					}
					return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
				}
				if b < 0x80 {
					if i == 4 && b > 1 {
						return "", errors.New("owned resource ID length overflows a 32-bit integer")
					}
					x = x | uint32(b)<<s
					buf := make([]byte, x)
					slog.Debug("reading owned resource ID bytes", "len", x)
					_, err = r.Read(buf)
					if err != nil {
						return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
					}
					if !utf8.Valid(buf) {
						return "", errors.New("owned resource ID is not valid UTF-8")
					}
					return wrpc.Own[OutgoingValue](buf), nil
				}
				x |= uint32(b&0x7f) << s
				s += 7
			}
			return "", errors.New("owned resource ID length overflows a 32-bit integer")
		}(r__)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[static]outgoing-value.new-outgoing-value`: %w", err__)
		return
	}
	return
}
func OutgoingValue_OutgoingValueWriteBody(ctx__ context.Context, wrpc__ wrpc.Invoker, self wrpc.Borrow[OutgoingValue]) (r0__ *wrpc.Result[wrpc.Own[OutputStream], struct{}], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "outgoing-value-write-body", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[wrpc.Own[OutputStream], struct{}], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				slog.Debug("reading `result::ok` payload")
				v, err := func(r interface {
					io.ByteReader
					io.Reader
				}) (wrpc.Own[OutputStream], error) {
					var x uint32
					var s uint
					for i := 0; i < 5; i++ {
						slog.Debug("reading owned resource ID length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
						}
						if b < 0x80 {
							if i == 4 && b > 1 {
								return "", errors.New("owned resource ID length overflows a 32-bit integer")
							}
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading owned resource ID bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return "", errors.New("owned resource ID is not valid UTF-8")
							}
							return wrpc.Own[OutputStream](buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return "", errors.New("owned resource ID length overflows a 32-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
				}
				return &wrpc.Result[wrpc.Own[OutputStream], struct{}]{Ok: &v}, nil
			case 1:
				var v struct{}
				return &wrpc.Result[wrpc.Own[OutputStream], struct{}]{Err: &v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]outgoing-value.outgoing-value-write-body`: %w", err__)
		return
	}
	return
}
func IncomingValue_IncomingValueConsumeSync(ctx__ context.Context, wrpc__ wrpc.Invoker, this wrpc.Own[IncomingValue]) (r0__ *wrpc.Result[IncomingValueSyncBody, Error], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, "wasi:blobstore/types@0.2.0-draft", "incoming-value.incoming-value-consume-sync", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(this), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `this` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[IncomingValueSyncBody, Error], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				slog.Debug("reading `result::ok` payload")
				v, err := func(r interface {
					io.ByteReader
					io.Reader
				}) ([]byte, error) {
					var x uint32
					var s uint
					for i := 0; i < 5; i++ {
						slog.Debug("reading byte list length", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return nil, fmt.Errorf("failed to read byte list length byte: %w", err)
						}
						if b < 0x80 {
							if i == 4 && b > 1 {
								return nil, errors.New("byte list length overflows a 32-bit integer")
							}
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading byte list contents", "len", x)
							_, err = io.ReadFull(r, buf)
							if err != nil {
								return nil, fmt.Errorf("failed to read byte list contents: %w", err)
							}
							return buf, nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return nil, errors.New("byte length overflows a 32-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
				}
				return &wrpc.Result[IncomingValueSyncBody, Error]{Ok: &v}, nil
			case 1:
				slog.Debug("reading `result::err` payload")
				v, err := func() (Error, error) {
					v, err := func(r interface {
						io.ByteReader
						io.Reader
					}) (string, error) {
						var x uint32
						var s uint8
						for i := 0; i < 5; i++ {
							slog.Debug("reading string length byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return "", fmt.Errorf("failed to read string length byte: %w", err)
							}
							if s == 28 && b > 0x0f {
								return "", errors.New("string length overflows a 32-bit integer")
							}
							if b < 0x80 {
								x = x | uint32(b)<<s
								buf := make([]byte, x)
								slog.Debug("reading string bytes", "len", x)
								_, err = r.Read(buf)
								if err != nil {
									return "", fmt.Errorf("failed to read string bytes: %w", err)
								}
								if !utf8.Valid(buf) {
									return string(buf), errors.New("string is not valid UTF-8")
								}
								return string(buf), nil
							}
							x |= uint32(b&0x7f) << s
							s += 7
						}
						return "", errors.New("string length overflows a 32-bit integer")
					}(r)
					return (Error)(v), err
				}()

				if err != nil {
					return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
				}
				return &wrpc.Result[IncomingValueSyncBody, Error]{Err: &v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[static]incoming-value.incoming-value-consume-sync`: %w", err__)
		return
	}
	return
}
func IncomingValue_IncomingValueConsumeAsync(ctx__ context.Context, wrpc__ wrpc.Invoker, this wrpc.Own[IncomingValue]) (r0__ *wrpc.Result[wrpc.Own[IncomingValueAsyncBody], Error], close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, "wasi:blobstore/types@0.2.0-draft", "incoming-value.incoming-value-consume-async", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(this), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `this` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[wrpc.Own[IncomingValueAsyncBody], Error], error) {
			slog.Debug("reading result status byte")
			status, err := r.ReadByte()
			if err != nil {
				return nil, fmt.Errorf("failed to read result status byte: %w", err)
			}
			switch status {
			case 0:
				slog.Debug("reading `result::ok` payload")
				v, err := func(r interface {
					io.ByteReader
					io.Reader
				}) (wrpc.Own[IncomingValueAsyncBody], error) {
					var x uint32
					var s uint
					for i := 0; i < 5; i++ {
						slog.Debug("reading owned resource ID length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read owned resource ID length byte: %w", err)
						}
						if b < 0x80 {
							if i == 4 && b > 1 {
								return "", errors.New("owned resource ID length overflows a 32-bit integer")
							}
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading owned resource ID bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read owned resource ID bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return "", errors.New("owned resource ID is not valid UTF-8")
							}
							return wrpc.Own[IncomingValueAsyncBody](buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return "", errors.New("owned resource ID length overflows a 32-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
				}
				return &wrpc.Result[wrpc.Own[IncomingValueAsyncBody], Error]{Ok: &v}, nil
			case 1:
				slog.Debug("reading `result::err` payload")
				v, err := func() (Error, error) {
					v, err := func(r interface {
						io.ByteReader
						io.Reader
					}) (string, error) {
						var x uint32
						var s uint8
						for i := 0; i < 5; i++ {
							slog.Debug("reading string length byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return "", fmt.Errorf("failed to read string length byte: %w", err)
							}
							if s == 28 && b > 0x0f {
								return "", errors.New("string length overflows a 32-bit integer")
							}
							if b < 0x80 {
								x = x | uint32(b)<<s
								buf := make([]byte, x)
								slog.Debug("reading string bytes", "len", x)
								_, err = r.Read(buf)
								if err != nil {
									return "", fmt.Errorf("failed to read string bytes: %w", err)
								}
								if !utf8.Valid(buf) {
									return string(buf), errors.New("string is not valid UTF-8")
								}
								return string(buf), nil
							}
							x |= uint32(b&0x7f) << s
							s += 7
						}
						return "", errors.New("string length overflows a 32-bit integer")
					}(r)
					return (Error)(v), err
				}()

				if err != nil {
					return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
				}
				return &wrpc.Result[wrpc.Own[IncomingValueAsyncBody], Error]{Err: &v}, nil
			default:
				return nil, fmt.Errorf("invalid result status byte %d", status)
			}
		}(r__, []uint32{0}...)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[static]incoming-value.incoming-value-consume-async`: %w", err__)
		return
	}
	return
}
func IncomingValue_Size(ctx__ context.Context, wrpc__ wrpc.Invoker, self wrpc.Borrow[IncomingValue]) (r0__ uint64, close__ func() error, err__ error) {
	if err__ = wrpc__.Invoke(ctx__, string(self), "size", func(w__ wrpc.IndexWriter, r__ wrpc.IndexReadCloser) error {
		close__ = r__.Close
		var buf__ bytes.Buffer
		writes__ := make(map[uint32]func(wrpc.IndexWriter) error, 1)
		write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(string(self), &buf__)
		if err__ != nil {
			return fmt.Errorf("failed to write `self` parameter: %w", err__)
		}
		if write0__ != nil {
			writes__[0] = write0__
		}
		_, err__ = w__.Write(buf__.Bytes())
		if err__ != nil {
			return fmt.Errorf("failed to write parameters: %w", err__)
		}
		r0__, err__ = func(r io.ByteReader) (uint64, error) {
			var x uint64
			var s uint8
			for i := 0; i < 10; i++ {
				slog.Debug("reading u64 byte", "i", i)
				b, err := r.ReadByte()
				if err != nil {
					if i > 0 && err == io.EOF {
						err = io.ErrUnexpectedEOF
					}
					return x, fmt.Errorf("failed to read u64 byte: %w", err)
				}
				if s == 63 && b > 0x01 {
					return x, errors.New("varint overflows a 64-bit integer")
				}
				if b < 0x80 {
					return x | uint64(b)<<s, nil
				}
				x |= uint64(b&0x7f) << s
				s += 7
			}
			return x, errors.New("varint overflows a 64-bit integer")
		}(r__)
		if err__ != nil {
			return fmt.Errorf("failed to read result 0: %w", err__)
		}
		return nil
	}); err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]incoming-value.size`: %w", err__)
		return
	}
	return
}
